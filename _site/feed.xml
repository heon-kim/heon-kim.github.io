<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-27T07:18:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Heon-Log</title><subtitle>this is my blog!</subtitle><author><name>heon</name></author><entry><title type="html">프로젝트 S 설명 및 회고</title><link href="http://localhost:4000/project/2024-03-25-project-s/" rel="alternate" type="text/html" title="프로젝트 S 설명 및 회고" /><published>2024-03-25T00:00:00+09:00</published><updated>2024-03-25T00:00:00+09:00</updated><id>http://localhost:4000/project/project-s</id><content type="html" xml:base="http://localhost:4000/project/2024-03-25-project-s/"><![CDATA[<h3 id="️프로젝트-설명">🗓️ 프로젝트 설명</h3>

<p>기존에 작성된 사용자 사이트와 관리자 사이트의 전체 UI/UX를 개선하고, 버그 및 코드 관리</p>

<p>클라우드와 앱패키지를 통해 서비스 출시하였습니다.</p>

<p>한 개의 프로젝트에 두 가지 사이트를 동시에 개발해야 했습니다.</p>

<ul>
  <li>사용자 사이트
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vanilla JS</code></li>
      <li>MS Office 문서 내의 <strong>애드인 기능</strong>을 통해 문서의 정보를 저장/확인하고, 문서 원본을 서버에 등록하고 증명을 받을 수 있는 서비스</li>
    </ul>
  </li>
  <li>관리자 사이트
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vue JS</code></li>
      <li>사용자가 저장한 문서의 정보의 현황을 관리하고, 서버에 저장된 문서 원본을 확인할 수 있는 서비스</li>
    </ul>
  </li>
</ul>

<h3 id="️프로젝트-시작">🗄️ 프로젝트 시작</h3>

<p>처음에는 프로젝트의 BUG들을 QA에게 전달받아 처리를 하는 일로 시작을 했습니다.</p>

<p>하지만 BUG가 너무 많았을 뿐더러, 사내의 다른 프로젝트들과 UI/UX가 차이가 많이 나서 먼저 전체의 UI/UX를 개선하면서 버그를 줄이는 프로젝트를 시작하게 되었습니다.</p>

<h3 id="️프로젝트-개발-및-배포-사이클-구체화">🗓️ 프로젝트 개발 및 배포 사이클 구체화</h3>

<p>프로젝트의 기한 관리나 문서 관리가 되고 있지 않아, 사내에서 사용하고 있는 관리 시스템을 이용하여 기한 관리와 문서 관리를 시작했습니다.</p>

<p><strong>업무 효율 향상</strong></p>

<p>기한 관리를 통해 업무 처리 속도를 가늠할 수 있게 되고, 문서 관리를 통해 다른 팀들과 의사소통 리소스를 절약할 수 있게 되어 업무 효율이 향상되었습니다. 이에 대한 회고를 아래 페이지에 작성해두었습니다.</p>

<p><a href="https://www.heon-kim.github.io/project/2024-03-16-project-manage">프로젝트의 기한을 관리하고, 문서를 관리 하며 느낀점</a></p>

<h3 id="uiux-개선">🎨 UI/UX 개선</h3>

<p><strong>공통컴포넌트 사용으로 개발 부담 감소</strong></p>

<p>사내 서비스들의 UI/UX를 공통으로 맞추어, 서비스들끼리 공통 컴포넌트를 공유하여 사용하도록 수정했습니다. 사내에서 사용하는 컴포넌트들의 UI/UX를 맞추니 서로의 코드를 참고하여 개발 부담이 많이 줄어든 것을 느꼈습니다.</p>

<p><strong>따로 함께 일하기</strong></p>

<p>사내의 프론트엔드 개발자끼리 코드를 100% 오픈하여 서로 참고하고 잘 모르는 부분은 서로 질문하고 도와주는 환경이 가장 좋았습니다. 각자 다른 프로젝트를 하고 있지만 하나의 서비스처럼 개발을 해서 함께 일하는 느낌이 가장 많이 들었던 프로젝트입니다.</p>

<h3 id="버그-개선">🐞 버그 개선</h3>

<p><strong>sonarQube 정적 분석을 통해 코드 품질 개선</strong></p>

<p>배포 프로세스 중에 sonarQube 정적 분석을 통해 코드의 품질을 평가를 하는 단계가 있습니다. 이때 Critical로 분류된 이슈가 100개 가까이 되어 QA 팀에서 코드의 품질을 개선해달라는 요청이 있었습니다. Critical로 분류된 이슈는 장애를 발생시킬 가능성이 높기 때문에 우선순위를 높여 처리를 하되, 1주일 단위로 Critical의 개수를 10개씩 줄여나가 모든 Critical 이슈를 처리했습니다.</p>

<p><strong>Clean Code의 중요성</strong></p>

<p>이 과정에서 가장 많이 생겼던 이슈가 하나의 함수안에 15개 이상의 조건이 있는 경우에 대한 이슈였습니다. 이때 하나의 함수를 기능에 따라 여러개의 함수로 분류하고, 단순 <code class="language-plaintext highlighter-rouge">if else</code> 문 보다는 <code class="language-plaintext highlighter-rouge">if return</code>을 통해 조건문 부하를 줄이고, <code class="language-plaintext highlighter-rouge">삼항연산자</code>를 이용해서 가독성을 높이는 방법으로 처리하니, 전보다 유지보수가 훨씬 쉬워진 것을 느끼고 가독성의 중요성을 깨달았습니다.</p>

<p><strong>서비스 품질 개선</strong></p>

<p>또한 QA 팀에서 수동 테스트 결과로 검출된 버그를 전달받아 2주에 한번 처리하여 기존 모든 페이지에서 발생하던 버그를 모두 처리하고 서비스의 품질을 높였습니다.</p>

<h3 id="e2e-테스트-도입">📝 E2E 테스트 도입</h3>

<p>개발 단계에서 발견되지 못하고 배포 요청을 하게 되는 일이 반복되자, QA팀에서 TDD를 제안했습니다. 초기에는 단순히 유닛테스트를 넣으려고 했지만, 사용자의 입장에서 사용 흐름을 테스트할 수 있는 E2E 테스트를 최종 도입하게 되었습니다.</p>

<p>아래 페이지에 E2E 테스트를 도입하기 전의 생각과 회고를 작성해두었습니다.</p>

<p><a href="https://www.heon-kim.github.io/fe-test/2024-03-14-fe-test-e2e/">E2E 테스트 도입</a></p>

<h3 id="배포-관리">🛫 배포 관리</h3>

<p><strong>개발환경</strong></p>

<p>Jenkins를 이용하여 Git → E2E → SonarQube → Docker 순으로 배포 관리했습니다.
로컬 환경에서 기능을 추가하는 중 발생한 이슈를 E2E 테스트와 SonarQube를 이용해 테스트를 해볼 수 있어서 코드의 안정성을 보장받을 수 있어 좋았습니다.</p>

<p><strong>SaaS 서비스</strong></p>

<p>Azure Pipeline을 이QA에게 배포 요청하면 QA테스트 → 사내 사용 테스트 → 배포를 하는 과정을 거쳤습니다. 이때 QA 테스트에서 버그가 발견되면 수정하고 다시 배포하는 과정을 반복하여 서비스를 안정적으로 배포했습니다.</p>

<p><strong>PaaS 서비스</strong></p>

<p>내부 폐쇄망을 사용하는 고객에게 서비스를 제공하기 위해 실제 물리서버에 쿠버네티스 환경을 만들고 서비스 이미지를 배포한 뒤 폐쇄망을 만들어 운영을 해보는 테스트를 해보았습니다. 웹 개발을 시작하면서 물리환경이나 네트워크 환경에 대해 공부해 볼 기회가 많이 없었는데, 이 기회를 통해 공부를 하면서 스스로 만든 서비스를 제공할 수 있어서 값진 경험이 되었습니다.</p>

<hr />

<h3 id="느낀점">🌈 느낀점</h3>

<h2 id="liked">Liked</h2>

<p>서비스를 배포하고 유지보수 관리를 하는 환경을 주도적으로 만들 수 있어 좋았습니다.</p>

<p>짧은 시간동안 모든 과정에 참여하여 서비스의 퀄리티를 손수 올릴 수 있어 좋았습니다.</p>

<h2 id="lacked">Lacked</h2>

<p>프로젝트를 이끌어 주시는 분이 있었지만, 함께 프로젝트를 만들어가는 팀원이 없어서 아쉬웠습니다. 주도적으로 일할 수 있어 좋았지만, 혼자 일하는 것 같은 느낌이 들 때가 있어 가끔 힘이 들 때가 있었습니다.</p>

<h2 id="learned">Learned</h2>

<p>sonarQube, e2e테스트, docker, kubernetes 등 코드 및 형상 관리에 대해 많이 배웠습니다.</p>

<p>단순히 웹사이트를 만드는 것이 전부가 아니라 유지 보수를 하기 쉽고, 오류가 적고 성능이 좋은 코드를 만드는 것이 중요하다는 것을 많이 배울 수 있어 좋았습니다.</p>]]></content><author><name>heon</name></author><category term="project" /><category term="project" /><summary type="html"><![CDATA[입사 후 첫번째 프로젝트 진행 회고]]></summary></entry><entry><title type="html">프로젝트의 기한을 관리하고, 문서를 관리 하며 느낀점</title><link href="http://localhost:4000/project/2024-03-16-project-manage/" rel="alternate" type="text/html" title="프로젝트의 기한을 관리하고, 문서를 관리 하며 느낀점" /><published>2024-03-16T00:00:00+09:00</published><updated>2024-03-16T00:00:00+09:00</updated><id>http://localhost:4000/project/project-manage</id><content type="html" xml:base="http://localhost:4000/project/2024-03-16-project-manage/"><![CDATA[<p>🪫 기존의 프로젝트 개발은 기한 관리, 문서 관리 창구 없이 무작위 방식으로 진행이 되었다.</p>

<p>이러한 방식은 효율적이지 않은 것 같아, <code class="language-plaintext highlighter-rouge">기한 관리</code>, <code class="language-plaintext highlighter-rouge">문서 관리</code> 창구 생성을 먼저 해야했다.</p>

<p>다행히 먼저 사내에 사용하고 있는 시스템이 있었다. (사실 어떤 툴이던지 상관은 없는 내용이다.)</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">기한 관리</code></strong> - Azure Devops의 Iteration 관리 시스템
    <ul>
      <li>Iteration 기간을 정해 Backlog에 task를 작성하고 그 기간에 task를 분배하여 기한을 관리한다.</li>
      <li><img src="https://heon-kim.github.io/assets/images/posts_img/project/2024-03-16-project-manage.png" alt="Alt text" /></li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">문서 관리</code></strong> - docusaurus의 md 파일 기반 정적 웹사이트 시스템
    <ul>
      <li>md파일을 작성하여 사내에서 전달에 필요한 파일들을 웹사이트에 올려두고 공유를 한다.</li>
      <li><img src="https://heon-kim.github.io/assets/images/posts_img/project/2024-03-16-project-manage-2.png" alt="Alt text" /></li>
    </ul>
  </li>
</ul>

<p>이 두 개의 툴을 이용하여 기한을 관리하고 문서를 관리한 경험에 대한 회고를 5L 방식으로 남겨둔다.</p>

<h2 id="liked">Liked</h2>

<h3 id="업무-효율이-증가했다">업무 효율이 증가했다.</h3>

<ul>
  <li>이전에 한 일들이 기록되어 있어,
    <ul>
      <li>⚡️ 성취감이 증가하고</li>
      <li>이전 Iteration을 통해 앞으로 하나의 Iteration동안 얼마나 일을 처리할 수 있는지 인사이트가 생겼다.</li>
    </ul>
  </li>
  <li>앞으로 할 일들이 기록되어 있어, 우선순위를 조정하고 개발일정을 조정할 수 있어 효율이 크게 증가했다.</li>
</ul>

<h3 id="의사소통-시간을-줄였다">의사소통 시간을 줄였다.</h3>

<ul>
  <li>배포 이미지 버전 마다 환경 구성이나 환경 변수 등이 변경될 수 있는데, md 파일로 작성하면, 정적 웹사이트에 올려두면 서로 바로 확인하여 사용할 수 있게 되어 의사소통을 하는 시간을 줄일 수 있었다.</li>
</ul>

<h2 id="learned">Learned</h2>

<h3 id="중요한-건-꺾이지-않는-마음">중요한 건 꺾이지 않는 마음(?)</h3>

<ul>
  <li>azure devops는 사내에서 사용하고 있던 툴이라서 약간의 부족함을 느껴 이런저런 툴을 많이 찾아보고 사용해보았는데, 결국 모든 툴들이 거기서 거기고 얼마나 부지런하게 계획하고 처리하느냐가 중요하다는 것을 깨달았다. 😂</li>
  <li>기한을 정해놓고 남들이 보지 않는다고 미루거나 넘어가지 않고, 기록하고 성취해야 내가 성장하고 더 좋은 결과를 낼 수 있다는것을 배웠다.</li>
</ul>

<h2 id="lacked">Lacked</h2>

<h3 id="한계가-있었다">한계가 있었다.</h3>

<ul>
  <li>스스로 관리를 하면서 기한을 임의로 조정하는 일이 늘어났다.
    <ul>
      <li>다른 사람이 보지 않는다는 이유로 기한을 조정하고 우선순위를 바꾸면서 루즈해지는 경향이 있는 것 같다.</li>
      <li>이 문제는 툴의 문제가 아닌 팀 협업의 부재의 부작용인 것 같았다.</li>
    </ul>
  </li>
</ul>

<h2 id="longed-for">Longed for</h2>

<p>업무 효율 증가</p>

<h2 id="lost">Lost</h2>

<p>혼자 일하는 거에 대한 상실감이 커지고 팀 협업이 하고 간절해졌다 😭</p>]]></content><author><name>heon</name></author><category term="project" /><category term="project" /><summary type="html"><![CDATA[개발 및 배포 사이클 구체화 회고]]></summary></entry><entry><title type="html">E2E 테스트 도입 계기와 도입 후 느낀 점</title><link href="http://localhost:4000/fe-test/2024-03-14-fe-test-e2e/" rel="alternate" type="text/html" title="E2E 테스트 도입 계기와 도입 후 느낀 점" /><published>2024-03-14T00:00:00+09:00</published><updated>2024-03-14T00:00:00+09:00</updated><id>http://localhost:4000/fe-test/fe-test-e2e</id><content type="html" xml:base="http://localhost:4000/fe-test/2024-03-14-fe-test-e2e/"><![CDATA[<h2 id="e2e-테스트-도입-계기">E2E 테스트 도입 계기</h2>

<p>서비스 개발이 완료되어 배포되기 전에는 서비스의 동작 테스트를 QA에서 일차적으로 테스트 단계를 거치게 된다.</p>

<p>개발자와 QA 사이의 시간이 늘어나면 서비스 배포에 걸리는 시간이 늘어나게 된다. 이 시간을 줄이기 위해서는 개발 단계에서 테스트를 먼저 진행하여 최대한 오류가 없는 상태로 배포 요청을 하는것이 좋다.</p>

<p>그렇다면 유닛테스트가 아닌 E2E 테스트를 도입하는 이유는 무엇일까?</p>

<p>E2E테스트는 모듈의 무결성과는 상관없이 실제 사용자의 사용 흐름이 오류없이 진행되는 가에 초점이 맞춰져 있다. 결국 서비스는 사용자에게 사용이 되어야하기 때문에, 사용 흐름 중에 발생된 문제가 가장 중요하게 해결되어야 할 문제이다.</p>

<p>따라서 개발 중 실제 사용자의 사용 흐름에 문제가 없는지 확인하기 위해 E2E 테스트를 도입하게 되었다.</p>

<h3 id="e2e-테스트를-도입하기-전-고려해야-할-점">E2E 테스트를 도입하기 전 고려해야 할 점</h3>

<ol>
  <li>테스트 시간이 오래 걸린다.
    <ol>
      <li>E2E 테스트는 서비스 사용의 흐름을 테스트하기 때문에 테스트에 오래 걸리고, 사용 시나리오가 변경되면 E2E 테스트도 수정되어야 하기 때문에 비용이 많이 발생하게 된다. 따라서 꼭 필요한 테스트만 수행해야 한다.</li>
    </ol>
  </li>
  <li>기존 QA의 업무와 겹치게 된다.
    <ol>
      <li>처음 E2E 테스트를 도입할 때 가장 많이 나온 불만이 QA에서 해야할 일을 왜 개발자가 시간을 들여야하는지에 대한 불만이었다. E2E 테스트가 시간 비용이 정말 많이 드는 일이기 때문에 개발자는 E2E테스트를 구축할 때 개발보다는 테스트에 시간을 많이 쓰게 된다. 이에 불만이 많이 생길 수 있다.</li>
      <li>한번 시나리오를 써두면 기본적인 테스트를 빠르게 자동으로 돌릴 수 있다. 다만 사용 시나리오가 변경되면 다시 E2E 테스트를 수정해야하고 시간이 많이 들기때문에 이 점에 대해 충분히 고려를 해야한다.</li>
    </ol>
  </li>
</ol>

<h3 id="그럼에도-e2e-테스트를-도입한-이유">그럼에도 E2E 테스트를 도입한 이유</h3>

<p>사용자의 사용 흐름에 맞게 테스트한 뒤 배포하기 때문에 코드에 대한 신뢰도가 상승한다. 꼭 필요한 기본 흐름에 대한 테스트가 구축이 되어 있다면 코드 작성 후 사이드 이펙트를 획기적으로 줄일 수 있는 방안이 될 수 있을 거라고 생각해 도입 결정을 하게 되었다.</p>

<h3 id="테스트-도입-후-느낀점">테스트 도입 후 느낀점</h3>

<ul>
  <li>생각보다 처음 테스트 환경을 구축하는 시간은 오래 걸리지 않는다.</li>
  <li>개발 단계에서의 사이드 이펙트를 자동으로 줄일 수 있어, 코드 신뢰성이 향상되고 개발 시간이 단축된다.</li>
  <li>하지만 테스트 코드를 작성하는 것은 프로젝트에 따라 아주 오래 걸릴 수 있다.
    <ul>
      <li>테스트 코드를 작성하는 시간을 줄이기 위해서는
        <ul>
          <li>처음부터 테스트 코드를 염두해두고 컴포넌트 단위를 테스트 단위에 맞춰 작성하는 것이 좋고,</li>
          <li>모든 코드를 테스트하는 것보다는 사용자 입장에서 사용자가 사용하게 되는 주된 흐름에 대해서만 테스트를 작성하는 것이 좋다.</li>
          <li>테스트 코드 작성법에 대한 이해도가 높아질 수록 코드 작성 시간이 줄어들고 테스트에 걸리는 시간도 줄어든다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>E2E 테스트만으로 모든 코드를 테스트하는 것은 효율적이지 않다고 느꼈다.
    <ul>
      <li>사용자의 주된 사용 흐름이 아닌 부분은 유닛 테스트를 도입하는 것도 고려해봐야겠다는 생각이 들었다.</li>
    </ul>
  </li>
</ul>

<h3 id="사용한-e2e-테스트-라이브러리">사용한 E2E 테스트 라이브러리</h3>

<ul>
  <li>
    <p><a href="https://webdriver.io/docs/why-webdriverio">WebdriverIO</a></p>
  </li>
  <li>다양한 프레임워크 호환
    <ul>
      <li>🌐 React, Vue, Angular, Svelte 또는 기타 프론트엔드 프레임워크로 작성된 <strong>최신 웹 애플리케이션</strong></li>
      <li>📱 에뮬레이터/시뮬레이터 또는 실제 장치에서 실행되는 <strong>하이브리드</strong> 또는 <strong>네이티브 모바일 애플리케이션</strong></li>
      <li>💻 <strong>네이티브 데스크톱 애플리케이션</strong> (예: Electron.js로 작성)</li>
      <li>📦 브라우저에서 웹 구성 요소의 <strong>단위 또는 구성 요소 테스트</strong></li>
    </ul>
  </li>
  <li>사용 방법을 위한 Docs와 API 명세서가 풍부하게 제공된다.</li>
  <li>테스트 결과를 다양한 Log, Report, Video 등 다양한 형식으로 확인할 수 있다.</li>
</ul>

<h3 id="참고하기-좋은-테스팅-전략">참고하기 좋은 테스팅 전략</h3>

<p>FE 테스트 전략과 E2E 테스트와 스토리북의 필요성에 대한 좋은 내용이다.</p>

<p>https://www.youtube.com/watch?v=q9d631Nl0_4&amp;t=345s</p>

<blockquote>
  <p>참고</p>

  <p>https://fe-developers.kakaoent.com/2023/230209-e2e/</p>

  <p>https://tech.kakao.com/2022/02/25/angular-e2e-testing-2/</p>

  <p>https://webdriver.io/docs/api</p>
</blockquote>]]></content><author><name>heon</name></author><category term="fe-test" /><category term="test" /><summary type="html"><![CDATA[FE 테스트로 유닛테스트가 아닌 E2E 테스트를 도입하게 된 이유]]></summary></entry><entry><title type="html">라우터 / L3 스위치 - 3계층 장비</title><link href="http://localhost:4000/network/2024-03-12-network-router/" rel="alternate" type="text/html" title="라우터 / L3 스위치 - 3계층 장비" /><published>2024-03-12T00:00:00+09:00</published><updated>2024-03-12T00:00:00+09:00</updated><id>http://localhost:4000/network/network-router</id><content type="html" xml:base="http://localhost:4000/network/2024-03-12-network-router/"><![CDATA[<blockquote>
  <p>🏷️ 개요</p>

  <p>라우터는 대표적인 3계층 장비로, 경로를 지정해주는 장비다.
들어오는 패킷의 목적지 IP 주소를 확인하고 자신이 가진 경로 정보를 이용해 패킷을 최적의 경로로 포워딩한다.
현대 네트워크 환경에서는 인터넷을 연결하기 위한 원격지 통신이 매우 중요한데, 라우터는 이러한 원격지 네트워크를 구성하는 핵심 장비다.</p>
</blockquote>

<p>💡 참고 - 라우터와 L3 스위치는 같은 기능을 하는데, 어떤 차이가 있을까?<br />
<code class="language-plaintext highlighter-rouge">기존</code>에는 라우터는 소프트웨어로 구현하고, 스위치는 하드웨어로 구현하는 형태로 구분하거나, 다양한 기능의 라우터와 패킷을 빨리 보내는데 최적화된 스위치로 구분했지만, <code class="language-plaintext highlighter-rouge">최근</code>에는 기술의 발전으로 라우터와 L3 스위치를 구분하기는 어렵다.<br />
이번 챕터에서 다루는 내용에 한해서 라우터와 L3 스위치는 모두 <code class="language-plaintext highlighter-rouge">동일하다</code>고 보면 된다.</p>

<h2 id="1-라우터의-동작-방식과-역할">1. 라우터의 동작 방식과 역할</h2>

<p>라우터는 다음과 같이 동작한다.</p>

<ol>
  <li><strong>경로 지정</strong>
    <ol>
      <li>다양한 경로 정보를 수집해 최적의 경로를 라우팅 테이블에 저장한 후</li>
      <li>패킷이 라우터로 들어오면</li>
      <li>도착지 IP 주소와 라우팅 테이블을 비교해 최선의 경로로 패킷을 내보낸다.</li>
    </ol>
  </li>
  <li><strong>브로드캐스트 컨트롤</strong>
    <ol>
      <li>들어온 패킷의 목적지 주소가 라우팅 테이블에 없으면 패킷을 버린다.</li>
    </ol>
  </li>
  <li><strong>프로토콜 변환</strong>
    <ol>
      <li>패킷 포워딩 과정에서 기존 2계층 헤더 정보를 제거한 후</li>
      <li>새로운 2계층 헤더를 만들어 낸다.</li>
    </ol>
  </li>
</ol>

<h3 id="11-경로-지정">1.1. 경로 지정</h3>

<p><strong>라우터의 가장 중요한 역할</strong></p>

<ol>
  <li>다양한 경로 정보를 수집해 최적의 경로를 라우팅 테이블에 저장한 후</li>
  <li>패킷이 라우터로 들어오면</li>
  <li>도착지 IP 주소와 라우팅 테이블을 비교해 최선의 경로로 패킷을 내보낸다.</li>
</ol>

<p>라우터는 IP 주소의 네트워크 주소와 호스트 주소를 이용해서 로컬 네트워크와 원격지 네트워크를 구분하여 경로를 찾을 수 있다.</p>

<p>라우터는 이 IP 주소를 확인해 원격지에 있는 적절한 경로로 패킷을 포워딩한다.</p>

<ol>
  <li>
    <p>경로 정보를 얻는 방법</p>

    <ol>
      <li>IP 주소를 입력하면서 자연스럽게 인접 네트워크 정보를 얻는 방법</li>
      <li>관리자가 직접 경로 정보를 입력하는 방법</li>
      <li>라우터끼리 서로 경로 정보를 자동으로 교환하는 방법</li>
    </ol>
  </li>
</ol>

<p><img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-03-12-network-router-1.png" alt="Alt text" /></p>

<p>이 방법을 통해 정확인 목적지 경로를 얻어 자신이 얻은 경로 정보에 포함되는 패킷만 포워딩한다.</p>

<h3 id="12-브로드캐스트-컨트롤">1.2. 브로드캐스트 컨트롤</h3>

<ul>
  <li>스위치
    <ul>
      <li>패킷의 도착지 주소를 모르면 플러딩을 통해 모든 포트에 패킷을 전달한다.</li>
      <li>LAN은 크기가 작아 플러딩에 대한 영향이 작고 도착지 네트워크 인터페이스 카드에서 자신의 주소와 패킷의 도착지 주소가 다르면 패킷을 버리기 때문에 네트워크에 큰 무리를 주지 않는다.</li>
    </ul>
  </li>
  <li>라우터
    <ul>
      <li>라우터는 패킷을 원격지로 보내는 것을 목표로 개발되어 3계층에서 동작하고 분명한 도착지 정보가 있을 때만 통신을 허락한다.</li>
      <li>인터넷 연결은 대부분 지정된 대역폭만 빌려 사용하므로 쓸모없는 통신이 네트워크를 차지하는 것을 최대한 막으려고 노력한다.
        <ul>
          <li>만약 LAN에서 스위치가 동작하는 것처럼 목적지가 없거나 명확하지 않은 패킷이 플러딩된다면 인터넷에 쓸모 없는 패킷이 가득 차 통신불능 상태가 될 수 있다.</li>
        </ul>
      </li>
      <li>라우터는 바로 연결되어 있는 네트워크 정보를 제외하고 경로 습득 설정을 하지 않으면 패킷을 포워딩 할 수 없다.</li>
      <li>라우터는 기본적으로 멀티캐스트 정보를 습득하지 않고 브로드캐스트 패킷을 전달하지 않는다.
        <ul>
          <li>이 기능을 통해 브로드캐스트가 다른 네트워크로 전파되는 것을 막을 수 있다.</li>
          <li>이 기능을 “브로드캐스트 컨트롤 / 멀티캐스트 컨트롤”이라고 한다.</li>
        </ul>
      </li>
      <li>네트워크에 브로드 캐스트가 많이 발생하는 경우, 라우터로 네트워크를 분리하면 브로드캐스트 네트워크를 분할해 네트워크 성능을 높일 수 있다.
        <h3 id="13-프로토콜-변환">1.3. 프로토콜 변환</h3>
      </li>
      <li>라우터의 또 다른 역할은 서로 다른 프로토콜로 구성된 네트워크를 연결하는 것.</li>
      <li>⇒ 이는 현재 대부분의 네트워크가 이더넷을 사용하면서 줄어든 역할이다.
        <ul>
          <li>과거에는 LAN에서 사용하는 프로토콜과 WAN에서 사용하는 프로토콜이 전혀 다른 공간이어서, LAN에서 사용하는 기술이 WAN으로 변환되어야만 통신이 가능했고 이 역할을 라우터가 담당했다.</li>
        </ul>
      </li>
      <li>라우터에 패킷이 들어오면 2계층까지의 헤더 정보를 벗기고 3계층 주소를 확인 후 2계층 헤더 정보를 새로 만들어 외부로 내보낸다.
        <ul>
          <li>LAN 구간에서 패킷이 라우터를 지나면서 헤더가 벗겨지고 WAN 구간으로 패킷이 나올 때 PPP 헤더로 변경되어 프로토콜이 변환된다.
<img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-03-12-network-router-2.png" alt="Alt text" />
라우터는 서브넷 단위로 라우팅 정보를 습득하고 라우팅 정보를 최적화하기 위해 서머리(Summary) 작업을 통해 여러 개의 서브넷 정보를 뭉쳐 전달합니다.
⇒ 그래서 라우터에 들어온 패킷의 목적지 주소와 라우터가 갖고 있는 라우팅 테이블 정보가 정확히 일치(Exact Match)하지 않더라도 수많은 정보 중 목적지에 가장 근접한 정보를 찾아 패킷을 포워딩해야 합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-경로-지정---라우팅스위칭">2. 경로 지정 - 라우팅/스위칭</h2>

<ul>
  <li>라우팅 - 라우터가 경로 정보를 얻는 방법 (라우팅 테이블을 만드는 방법)</li>
  <li>스위칭 - 라우터가 경로를 지정하는 방법</li>
</ul>

<h3 id="21-라우팅-동작과-라우팅-테이블">2.1. 라우팅 동작과 라우팅 테이블</h3>

<ol>
  <li><strong>라우팅 동작</strong>
    <ul>
      <li>홉 바이 홉 라우팅 (Hop-by-Hop Routing)
        <ul>
          <li>단말부터 목적지까지의 경로를 모두 책임지는 것이 아니라, 인접한 라우터까지만 경로를 지정하면 인접 라우터에서 최적의 경로를 다시 파악한 후 라우터로 패킷을 포워딩한다.</li>
          <li>이때 인접한 라우터를 Next Hop이라고 부른다.
<img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-03-12-network-router-3.png" alt="Alt text" /></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>Next Hop을 지정하는 방법
    <ol>
      <li>다음 라우터의 IP 주소를 지정하는 방법</li>
      <li>라우터의 나가는 인터페이스를 지정하는 방법
        <ol>
          <li>상대방 Next Hop 라우터의 IP를 모르더라도 MAC 주소 정보를 알아낼 수 있을 때만 사용</li>
        </ol>
      </li>
      <li>라우터의 나가는 인터페이스와 다음 라우터의 IP를 동시에 지정하는 방법
        <ol>
          <li>VLAN 인터페이스와 같은 논리적인 인터페이스를 사용할 수 있다.</li>
        </ol>
      </li>
    </ol>
  </li>
</ul>

<ol>
  <li><strong>라우팅 테이블</strong>
    <ul>
      <li>라우팅 테이블에 저장하는 데이터
        <ol>
          <li>목적지 주소</li>
          <li>Next Hop IP 주소, 나가는 로컬 인터페이스</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>참고- PBR (Policy Based Routing)</p>

  <p>라우터에서 PBR 기능을 사용할 수 있지만, 출발지 주소를 이용해야하기 때문에 라우터 테이블 외에도 라우터 정책과 관련된 별도 설정이 필요하다.
PBR은 출발지 IP와 도착지 IP, 포트 번호와 같은 다양한 조건을 합쳐 사용할 수 있다.
출발지 주소를 이용한다는 의미로 소스 라우팅이라고 부르기도 한다.</p>
</blockquote>

<blockquote>
  <p>참고- 루프가 없는 3계층: TTL (Time To Live)</p>

  <p>3계층의 IP 헤더에는 TTL 이라는 헤더가 있다.
이 필드는 패킷이 네트워크에 살아 있을 수 있는 시간(홉)을 제한한다.
TTL은 실제 시간이 아니라 홉을 지칭하며, 홉을 지날 때 마다 TTL 값이 1씩 줄어든다.</p>

  <p>두 대의 라우터가 서로를 참조하게 되면 루프가 생겨 사라지지 않는 유령 패킷이 생성되는데, TTL을 이용해 홉수가 제한이 되면 이 루프를 방지할 수 있다.</p>
</blockquote>

<h3 id="22-라우팅---라우터가-경로-정보를-얻는-방법-라우팅-테이블을-만드는-방법">2.2. 라우팅 - 라우터가 경로 정보를 얻는 방법 (라우팅 테이블을 만드는 방법)</h3>

<blockquote>
  <ol>
    <li>다이렉트 커넥티드</li>
    <li>스태틱 라우팅</li>
    <li>다이나믹 라우팅</li>
  </ol>
</blockquote>

<ol>
  <li>
    <p><strong>다이렉트 커넥티드</strong></p>

    <p>라우터나 PC에서는 IP 주소를 입력할 때 사용된 IP 주소와 서브넷 마스크로 알게된 네트워크 주소 정보로 라우팅 테이블을 자동으로 만든다.</p>

    <p>이 경로 정보를 다이렉트 커넥티드라고 부른다.</p>

    <p>이 정보는 인터페이스에 IP를 설정하면 자동 생성되는 정보이므로 정보를 강제로 지울 수 없고, 네트워크 설정을 삭제하거나 해당 네트워크 인터페이스가 비활성되어야만 자동으로 사라진다.</p>

    <ul>
      <li>다이렉트 커넥티드로 생성된 정보는 넥스트 홉에 ‘connected’라고 표기된다.</li>
    </ul>

    <p><img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-03-12-network-router-4.png" alt="Alt text" /></p>
  </li>
  <li>
    <p><strong>스태틱 라우팅</strong></p>

    <p>관리자가 목적지 네트워크와 넥스트 홉을 라우터에 직접 지정해 경로 정보를 입력하는 것</p>

    <p>다이나믹 커넥티드와 마찬가지로 연결된 인터페이스 정보가 삭제되거나 비활성화되면 자동으로 삭제된다.</p>

    <p>다만 물리 인터페이스가 아닌 논리 인터페이스는 물리 인터페이스가 비활성화 되더라도 비활성화 되지 않을 수 있어 라우팅 테이블에서 사라지지 않을 수 있다.</p>

    <ul>
      <li>R1과 R2에 각각 넥스트홉에 서로의 주소가 설정되어 있다. 양방향 통신을 해야하기 때문에 되돌아오는 패킷을 고려함.</li>
    </ul>

    <p><img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-03-12-network-router-5.png" alt="Alt text" /></p>

    <ul>
      <li>스태틱 라우팅의 한계
        <ol>
          <li>라우터 너머 다른 라우터의 상태 정보를 파악할 수 없어 라우터 사이의 회선이나 라우터에 장애가 발생하면 장애 상황을 파악하고 대체 경로로 패킷을 보낼 수 없다.
            <ul>
              <li>목적지 R4로 패킷을 보내기 위해 R2 또는 R3 홉으로 패킷을 보내는데, R2-R4 사이의 경로의 장애를 발견하지 못하고 패킷을 버리게 된다.
<img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-03-12-network-router-6.png" alt="Alt text" /></li>
            </ul>
          </li>
          <li>관리자가 관리해야하는 네트워크 수가 많아지고 복잡해지면 관리자가 직접 수정하는데에 한계가 있다.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>다이나믹 라우팅</strong></p>

    <p>다이나믹 라우팅은 이러한 스태틱 라우팅의 단점을 보완한다.</p>

    <p>다이나믹 라우팅은 라우터끼리 자신이 알고 있는 경로 정보나 링크 상태 정보를 교환해 전체 네트워크 정보를 학습한다.</p>

    <p>주기적으로 또는 상태 정보가 변경될 때 라우터끼리 경로 정보가 교환되므로 장애가 발생하면 이 상황을 인지해 대체 경로로 포워딩 할 수 있다.</p>

    <p>위 그림처럼 다이나믹 라우팅에서는 자신이 광고할 네트워크를 선언해주어야 한다.</p>

    <p>다이나믹 라우팅은 다양한 경로 정보를 체계적으로 데이터베이스화하여 <code class="language-plaintext highlighter-rouge">토폴로지 테이블</code>에 저장하고, 순위를 부여해서 최적의 경로만 추려 <code class="language-plaintext highlighter-rouge">라우팅 테이블</code>에 저장한다.</p>

    <p>라우터는 이렇게 얻은 최적의 경로를 이용하여, 전체 경로 중에서 다음 라우터 사이의 홉까지의 최적의 경로만을 이용하여 패킷을 포워딩할 수 있다.</p>
  </li>
</ol>

<h3 id="23-스위칭---라우터가-경로를-지정하는-방법">2.3. 스위칭 - 라우터가 경로를 지정하는 방법</h3>

<p>패킷이 들어와 라우팅 테이블을 참조하고 최적의 경로를 찾아 라우터 외부로 포워딩하는 작업</p>

<p>들어온 패킷의 목적지가 라우팅 테이블에 있는 정보와 완벽히 일치하지 않는 경우, 라우팅 테이블에서 가장 좋은 항목을 찾는 알고리즘이 필요한다.</p>

<p><img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-03-12-network-router-7.png" alt="Alt text" /></p>

<ol>
  <li>
    <p>롱기스트 프리픽스 매치 (LPM, 맥시멈 프리픽스 매치)</p>

    <ol>
      <li>
        <p>라우팅 테이블과 도착지 정보가 매치 ⇒ 10.0.0.0/8, 10.1.0.0/16, 10.1.1.0/24</p>

        <p><em>⇒ 10.0.0.0/8은 10.0.0.0 ~ 10.255.255.255 범위</em></p>

        <p><em>⇒ 10.1.0.0/16은 10.1.0.0 ~ 10.1.255.255 범위</em></p>

        <p><em>⇒ 10.1.1.0/24는 10.1.1.0 ~ 10.1.1.255 범위</em></p>
      </li>
      <li>자리수 매치 ⇒ 10.1.2.0/24, 10.1.2.9/32 x</li>
      <li>옥텟 정보 매치 ⇒ 10.1.1.5/32 x</li>
      <li>목적지에 가장 가까운 정보는 <code class="language-plaintext highlighter-rouge">10.1.1.0/24</code></li>
    </ol>

    <p>하지만 이와 같이 부정확한 정보 중 가장 비슷한 경로를 찾는 작업은 많은 리소스를 소모해 부하가 많이 걸린다.</p>
  </li>
  <li>
    <p>캐싱</p>

    <p>롱기스프 프리픽스 매치의 반복 작업을 줄여주는 기술</p>

    <p>한 번 스위칭 작업을 수행한 정보는 캐시에 저장하고 뒤에 들어오는 패킷은 캐시를 먼저 확인한다.</p>

    <p>이런 기술이 유용한 것은 패킷 네트워크에서 데이터를 보내기 위해 동일한 출발지 IP, 동일한 목적지 IP, 포트 번호로 여러 개의 패킷이 연속적으로 보내기 때문이다.</p>

    <ul>
      <li>캐시 사용 기법
        <ol>
          <li>단순히 목적지 IP만 캐시하는 기법</li>
          <li>출발지와 목적지 IP 모두 캐시하는 기법</li>
          <li>포트 번호 정보까지 포함해 플로를 모두 저장하는 기법</li>
          <li>넥스트 홉 L2 정보까지 저장해 스위칭 시간을 줄이는 기법</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h3 id="24-라우팅-스위칭-우선순위">2.4. 라우팅, 스위칭 우선순위</h3>

<ol>
  <li>
    <p>라우팅 우선순위</p>

    <p>위에서 언급한 것처럼 다이나믹 라우팅은 다양한 경로 정보를 체계적으로 데이터베이스화하여 <code class="language-plaintext highlighter-rouge">토폴로지 테이블</code>에 저장하고, 우선순위를 부여해서 최적의 경로만 추려 <code class="language-plaintext highlighter-rouge">라우팅 테이블</code>에 저장한다.</p>

    <p>이 우선순위는 경로를 받은 방법과 거리를 기준으로 정한다.</p>

    <p>목적지 네트워크 정보가 동일한 서브넷을 사용하는 경우, 정보를 얻은 소스에 따라 가중치를 정한다.</p>

    <p>이 가중치 값은 라우팅 정보의 분류와 마찮가지로 크게 3가지로 나뉜다.</p>

    <ul>
      <li>내가 갖고 있는 네트워크(다이렉트 커넥티드) - <strong>우선순위: 제일 높음</strong></li>
      <li>내가 경로를 직접 지정한 네트워크(스태틱 라우팅) - <strong>우선순위: 중간</strong></li>
      <li>경로를 전달받은 네트워크(다이나믹 라우팅) - <strong>우선순위: 낮음</strong></li>
    </ul>

    <p>또한 어떤 라우팅 프로토콜을 통해 경로 정보를 얻었는가에 따라 우선순위가 다르다.</p>

    <p>기본적인 우선순위는 미리 정해져있지만 필요에 따라 관리자가 조정할 수 있다. 이런 우선순위를 AD(Administrative Distance, 관리 거리)라 하며 라우터 생산업체마다 AD값이 조금씩 다르다.</p>

    <table>
      <thead>
        <tr>
          <th>우선순위</th>
          <th>기본 디스턴스</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0</td>
          <td>다이렉트 커넥티드</td>
        </tr>
        <tr>
          <td>1</td>
          <td>스태틱 라우팅</td>
        </tr>
        <tr>
          <td>20</td>
          <td>External BGP</td>
        </tr>
        <tr>
          <td>110</td>
          <td>OSPF</td>
        </tr>
        <tr>
          <td>114</td>
          <td>IS-IS</td>
        </tr>
        <tr>
          <td>120</td>
          <td>RIP</td>
        </tr>
        <tr>
          <td>200</td>
          <td>Internal BGP</td>
        </tr>
        <tr>
          <td>255</td>
          <td>Unknown</td>
        </tr>
      </tbody>
    </table>

    <p>경로 정보를 받은 소스가 같아 가중치 값이 동일한 경우에는 코스트 값으로 우선순위를 정한다.</p>

    <p>코스트값도 동일하면 ECMP (Equal Cost Multi Path) 기능으로 트래픽을 분산한다.</p>
  </li>
  <li>
    <p>스위칭 우선순위</p>

    <p>롱기스트 프리픽스 매치 기법으로 우선순위를 정한다.</p>
  </li>
  <li>
    <p>라우팅, 스위칭 역할을 하나로 묶은 우선순위는 다음과 같다.</p>

    <table>
      <thead>
        <tr>
          <th>우선순위</th>
          <th>구분</th>
          <th>적용 방법</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>롱기스트 매치</td>
          <td>스위칭</td>
        </tr>
        <tr>
          <td>2</td>
          <td>AD</td>
          <td>라우팅</td>
        </tr>
        <tr>
          <td>3</td>
          <td>코스트</td>
          <td>라우팅</td>
        </tr>
        <tr>
          <td>4</td>
          <td>ECMP</td>
          <td>라우팅</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>]]></content><author><name>heon</name></author><category term="network" /><category term="network" /><summary type="html"><![CDATA[라우팅, 스위칭]]></summary></entry><entry><title type="html">javascript DeepDive 스터디 회고</title><link href="http://localhost:4000/study/2024-03-09-js-study/" rel="alternate" type="text/html" title="javascript DeepDive 스터디 회고" /><published>2024-03-09T00:00:00+09:00</published><updated>2024-03-09T00:00:00+09:00</updated><id>http://localhost:4000/study/js-study</id><content type="html" xml:base="http://localhost:4000/study/2024-03-09-js-study/"><![CDATA[<blockquote>
  <p>🌷 <strong>노션</strong></p>

  <p><a href="https://www.notion.so/Javascript-Deep-Dive-930ec74a21a64f5082767ed48d81a054?pvs=21">Javascript Deep Dive 스터디</a></p>

  <p>🌷 <strong>레파지토리</strong></p>

  <p>https://github.com/Javascript-sc/javascript-deepdive</p>
</blockquote>

<hr />

<h3 id="기간">기간</h3>

<p>2023-01 ~ 2023-12</p>

<hr />

<h3 id="스터디에-중간-합류를-했다">스터디에 중간 합류를 했다.</h3>

<p>이미 시작된 스터디라 중간 합류가 고민이 되었지만, 사내 프론트엔드 개발자분들과의 소통 창구가 될 수 있을 것 같고, 자바크립트에 관해 깊이 공부해볼 수 있는 기회라고 생각하여 제의를 받은 당일 합류 의사를 밝히며 들어갈 수 있었다.</p>

<h3 id="스터디-방식이-효과적이었다">스터디 방식이 효과적이었다.</h3>

<ul>
  <li>스터디 방식
    <ul>
      <li>모든 스터디원이 책을 읽고 정리를 해오면 다음 스터디 시간에 사다리타기를 통해 발표자를 뽑아 발표를 한다.</li>
      <li>책을 읽고 정리를 하면서 궁금했던 점이 있다면 질문을 작성하고, 이해를 했다면 퀴즈를 만들어서 스터디 시간동안 질문과 퀴즈를 돌아가면서 대답을 한다.</li>
    </ul>
  </li>
</ul>

<p>처음 해보는 스터디 방식이었는데 공부를 하는데 꽤나 도움이 되었다. 랜덤으로 발표자가 정해지니 항상 발표를 준비하는 마음으로 공부를 하게 되고, 스터디가 끝나면 예상치 못했던 질문들과 퀴즈들로 알찬 정보들을 많이 깨닫고 갈 수 있었다.</p>

<p>한 가지 단점은 항상 발표를 준비하는 마음으로 공부를 하게 되니 매주 시간을 많이 쓰게 되었다. 공부를 하는데 시간을 많이 쓰는 것은 아주 장점이지만, 업무가 많은 주에는 버겁게 느껴질 때가 있었다.</p>

<hr />

<h2 id="liked">Liked</h2>

<p>몰랐던 메서드들을 많이 알게 되어 실무에 많이 써먹을 수 있었다.</p>

<p>프론트엔드 개발자분들과 소통의 창구가 열려서 일을 하면서 서로 도움을 주고 받을 수 있어서 좋았다.</p>

<h2 id="lacked">Lacked</h2>

<p>1 처음부터 참여하지 못해서 아쉬웠다..</p>

<p>2 너무 방대한 양이라 뒷부분으로 갈 수록 앞부분의 내용이 점점 잊혀져 갔다. 시간을 내서 2회독도 도전해봐야겠다.</p>

<h2 id="learned">Learned</h2>

<p>특히 Event를 다루는 방법들과, 디바운스를 다루는 방법은 요긴하게 쓰고 있다.</p>

<h2 id="longed-for">Longed for</h2>

<p>javascript 마스터하기 ⇒ 마스터하려면 한참 멀었다..!</p>

<h2 id="lost">Lost</h2>

<p>소정의 간식 비용,,(퀴즈를 못만들면 벌금..))</p>

<hr />]]></content><author><name>heon</name></author><category term="study" /><category term="javascript" /><summary type="html"><![CDATA[유익했던 스터디를 마치며]]></summary></entry><entry><title type="html">2024 정보처리기사 1회차 실기 정보</title><link href="http://localhost:4000/study/2024-01-19-cert-data/" rel="alternate" type="text/html" title="2024 정보처리기사 1회차 실기 정보" /><published>2024-01-19T00:00:00+09:00</published><updated>2024-01-19T00:00:00+09:00</updated><id>http://localhost:4000/study/cert-data</id><content type="html" xml:base="http://localhost:4000/study/2024-01-19-cert-data/"><![CDATA[<blockquote>
  <p>🌷 <strong>개요</strong></p>
</blockquote>

<ol>
  <li>일정</li>
</ol>

<ul>
  <li>필기 원서접수 01.23(화) ~ 01.26(금)</li>
  <li>필기 시험 02.15(목) ~ 03.07(목)</li>
  <li>
    <p>필기 합격자발표 03.13(수)</p>
  </li>
  <li>
    <p>서류제출 02.15(목) ~ 03.25(월)</p>
  </li>
  <li>실기 원서접수 <code class="language-plaintext highlighter-rouge">03.26(화) ~ 03.29(금)</code>`</li>
  <li>실기 시험 <code class="language-plaintext highlighter-rouge">04.27(토)</code>`</li>
  <li>합격자발표 06.18(화)</li>
</ul>

<ol>
  <li>준비물</li>
</ol>

<ul>
  <li>필기 : 수험표(스마트폰), 신분증</li>
  <li>실기 : 검정펜, 수험표(출력), 신분증</li>
</ul>

<ol>
  <li>시험</li>
</ol>

<ul>
  <li>필기 : CBT로 컴퓨터 제출 후 바로 점수 확인</li>
  <li>실기 : 종이에 펜으로 작성하여 제출 후 점수는 2달 후 확인</li>
</ul>

<ol>
  <li>공부</li>
</ol>

<ul>
  <li>필기/실기 모두 기출문제를 외우면 쉬움. 답을 외우기 보다는 푸는 방법을 외우는 것이 좋다.</li>
  <li>필기는 기출 3회독 이상, 문제를 보면 답이 바로 나올 정도로 공부하기.</li>
  <li>실기는 이론 공부 필요.
    <ul>
      <li>시나공 무료 인강 시청</li>
      <li><a href="https://m.blog.naver.com/dlqnf33/223124123745?referrerCode=1">요약본, 기출문제 풀기 참고 블로그</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>heon</name></author><category term="study" /><category term="study" /><summary type="html"><![CDATA[정처기 합격 해보자]]></summary></entry><entry><title type="html">스위치의 추가 기능 - STP</title><link href="http://localhost:4000/network/2024-01-16-network-switch2/" rel="alternate" type="text/html" title="스위치의 추가 기능 - STP" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/network/network-switch2</id><content type="html" xml:base="http://localhost:4000/network/2024-01-16-network-switch2/"><![CDATA[<blockquote>
  <p>🌷 <strong>개요</strong></p>

  <p><strong>스위치</strong></p>

  <ul>
    <li>2계층 장비</li>
    <li>네트워크의 가장 핵심적인 장비</li>
    <li>MAC 주소를 기반으로 동작</li>
  </ul>

  <p><strong>스위치의 기본 동작</strong></p>

  <ul>
    <li>네트워크 중간에서 패킷을 받아, 필요한 곳에만 보내준다. (네트워크의 통신을 중재)</li>
    <li>아무 설정을 하지 않고 연결만 해도 MAC 주소를 기반으로 패킷을 전달한다.</li>
  </ul>

  <p><strong>추가 기능</strong></p>

  <ul>
    <li>VLAN 기능 : 논리적으로 네트워크를 분리</li>
    <li>STP 기능 (스패닝 트리 프로토콜) : 네트워크의 루프 방지</li>
  </ul>
</blockquote>

<h1 id="stp">STP</h1>

<h2 id="1-stp가-필요한-이유">1. STP가 필요한 이유</h2>

<ul>
  <li><strong>네트워크 루프</strong>
    <ul>
      <li>SPoF를 피하기 위해 이중화, 다중화된 네트워크를 사용하게 되는데, 이 과정에서 스위치를 2대 이상 사용하게 되면 패킷이 네트워크를 돌고 돌아 네트워크를 마비시킬 수 있다.</li>
    </ul>
  </li>
  <li>
    <p>STP는 루프를 <code class="language-plaintext highlighter-rouge">확인</code>하고, 적절히 포트를 사용하지 못하게 만들어 루프를 <code class="language-plaintext highlighter-rouge">예방</code>한다.</p>
  </li>
  <li>루프의 대부분의 원인 : 브로드캐스트 스톰</li>
</ul>

<h3 id="브로드캐스트-스톰">브로드캐스트 스톰</h3>

<ul>
  <li>
    <p>발생</p>

    <ol>
      <li>루프 구조로 네트워크가 연결된 환경</li>
      <li>단말에서 브로드캐스트를 발생시킴</li>
      <li>스위치는 패킷을 모든 포트로 플러딩</li>
      <li>이 패킷을 받은 스위치는 모든 포트로 다시 플러딩</li>
      <li>반복</li>
    </ol>
  </li>
  <li>효과
    <ul>
      <li>2계층 패킷은 수명을 가지고 있지 않기 때문에 패킷 하나가 죽지 않고 전체 네트워크 대역폭을 차지할 수 있다.</li>
    </ul>
  </li>
  <li>결과
    <ul>
      <li>네트워크에 접속된 단말의 속도가 느려진다.</li>
      <li>네트워크 접속 속도가 느려진다. (거의 통신 불가)</li>
      <li>네트워크에 설치된 스위치의 모든 LED가 빠른 속도로 깜빡인다.</li>
    </ul>
  </li>
  <li>지속
    <ul>
      <li>케이블을 제거할 때까지 네트워크 마비 지속</li>
    </ul>
  </li>
</ul>

<h3 id="mac-어드래스-플래핑-스위치-mac-어드레스-러닝-중복">MAC 어드래스 플래핑 (스위치 MAC 어드레스 러닝 중복)</h3>

<ul>
  <li>발생
    <ol>
      <li>스위치는 출발지 MAC 주소를 학습힌다.</li>
      <li>스위치 MAC 주소 테이블에서는 하나의 MAC 주소에 대해 하나의 포트만 학습할 수 있다.</li>
      <li>동일한 MAC 주소가 여러 포트에서 학습되면 MAC 주소 테이블이 중복되어 정상적으로 동작하지 않는다.</li>
    </ol>
  </li>
  <li>결과
    <ul>
      <li>스위치에서 학습된 주소의 포트가 계속 변경되어 패킷을 플러딩한다.</li>
    </ul>
  </li>
  <li>예방
    <ul>
      <li>루프 구성 포트 중 하나의 포트만 셧다운 시키면 루프를 예방할 수 있다.
        <ul>
          <li>사용자가 직접 포트를 조작하는 것은 바람직하지 않다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-stp란">2. STP란?</h2>

<ul>
  <li>스패닝 트리 프로토콜</li>
  <li>
    <p>루프를 <code class="language-plaintext highlighter-rouge">확인</code>하고 적절히 포트를 사용하지 못하게 만들어 루프를 <code class="language-plaintext highlighter-rouge">예방</code>하는 메커니즘</p>
  </li>
  <li>루프를 <code class="language-plaintext highlighter-rouge">확인</code>하는 방법
    <ol>
      <li>스위치는 BPDU(브릿지 프로토콜 데이터 단위)라는 프로토콜을 통해 정보를 전달</li>
      <li>이 정보를 이용해 전체 네트워크 트리를 만들어 루프 구간을 확인</li>
    </ol>
  </li>
  <li>루프를 <code class="language-plaintext highlighter-rouge">예방</code>하는 방법
    <ul>
      <li>확인된 루프 지점을 트래픽이 통과하지 못하도록 차단</li>
    </ul>
  </li>
</ul>

<h3 id="21-스위치-포트의-상태-변화">2.1. 스위치 포트의 상태 변화</h3>

<ul>
  <li><img src="https://heon-kim.github.io/assets/images/posts_img/2024-01-16-network-switch2.png" alt="스위치 포트의 상태 변화" /></li>
</ul>

<ol>
  <li>Blocking : 패킷 데이터를 차단한 상태로 BPDU를 기다린다. (20초)</li>
  <li>Listening : 포트를 전송 상태로 변경할지 결정 (15초)</li>
  <li>Learning : MAC 주소 러닝 (15초)</li>
  <li>Forwarding : 패킷을 포워딩</li>
</ol>

<ul>
  <li>=&gt; 총 50초 소요</li>
</ul>

<h3 id="22-stp-동작-방식">2.2. STP 동작 방식</h3>

<ul>
  <li>루트 스위치 설정
    <ul>
      <li>전체 네트워크에서 하나의 스위치를 선정</li>
      <li>루트 스위치로 선정된 스위치는 2초마다 자신을 대표 스위치로 적은 BPDU를 전달</li>
      <li>새로운 스위치가 들어오면 BPDU의 BridgeID가 더 작은 값을 루트 스위치로 설정</li>
    </ul>
  </li>
  <li>루트 포트 설정
    <ul>
      <li>루트 스위치의 바로 옆 스위치의 포트</li>
    </ul>
  </li>
  <li>지정 포트 설정
    <ul>
      <li>루트 스위치에서 떨어져있는 스위치의 포트
        <ul>
          <li>루트 포트와 연결된 포트는 지정 포트로 설정</li>
          <li>루트 포트와 연결되지 않은 포트는 대체 포트로 설정, 차단 상태로 설정</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-향상된-stp-rstp-mst">3. 향상된 STP (RSTP, MST)</h2>

<ul>
  <li>문제
    <ol>
      <li>STP가 설정된 스위치는 블로킹 상태에서 포워딩 상태가 되는데까지 50초가 걸린다.
        <ul>
          <li>TCP 기반 애플리케이션은 네트워크가 끊겼을 때 이렇게 긴 시간을 기다려주지 못하기 때문에 통신이 끊길 수 있다.</li>
        </ul>
      </li>
      <li>스위치에 여러개의 VLAN이 있으면 각 VLAN별로 STP를 계산하면서 부하가 걸린다.</li>
    </ol>
  </li>
  <li>해결
    <ol>
      <li>RSTP</li>
      <li>MST</li>
    </ol>
  </li>
</ul>

<h3 id="31-rstp">3.1. RSTP</h3>

<ul>
  <li>시간이 너무 오래 걸리는 문제를 해결하기 위해 개발</li>
  <li>
    <p>Rapid Spanning Tree Protocol</p>
  </li>
  <li>공통점
    <ul>
      <li>기본적인 구성과 동작 방식은 STP와 같다.</li>
    </ul>
  </li>
  <li>차이점
    <ul>
      <li>BPDU 메시지 형식이 다양해져 여러가지 상태 매시지를 교환할 수 있다.
        <ul>
          <li>STP는 2가지</li>
          <li>RSTP는 8비트를 모두 활용</li>
        </ul>
      </li>
      <li>네트워크 전파 시간을 줄일 수 있다.
        <ul>
          <li>STP는 루트 브릿지만 토폴로지 정보를 보낼 수 있어 말단-&gt;루트-&gt;말단의 과정을 거쳐야함.</li>
          <li>RSTP는 모든 스위치가 토폴로지 정보를 보낼 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="32-mst">3.2. MST</h3>

<ul>
  <li>일반 STP
    <ul>
      <li>VLAN 개수와 상관없이 스패닝 트리 한개만 동작</li>
      <li>루프가 생기는 토폴로지에서 한개의 포트와 회선만 활성화할 수 있어 비효율적이다.</li>
      <li>최적의 경로를 다른 포트가 사용중이면 사용할 수 없음</li>
    </ul>
  </li>
  <li>PVST
    <ul>
      <li>일반 STP의 문제를 해결</li>
      <li>VLAN마다 별도의 경로와 트리를 만들 수 있음</li>
      <li>경로 셰어링을 통해 최적의 경로를 사용할 수 있다.</li>
      <li>VLAN마다 별도의 스패닝 트리가 동작해 부담이 된다.</li>
    </ul>
  </li>
  <li>MST
    <ul>
      <li>PVST의 문제를 해결</li>
      <li>여러개의 VLAN을 그룹으로 묶고, 그룹마다 별도의 스패닝 트리 동작</li>
    </ul>
  </li>
</ul>]]></content><author><name>heon</name></author><category term="network" /><category term="network" /><summary type="html"><![CDATA[STP]]></summary></entry><entry><title type="html">스위치의 추가 기능 - VLAN</title><link href="http://localhost:4000/network/2024-01-16-network-switch/" rel="alternate" type="text/html" title="스위치의 추가 기능 - VLAN" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/network/network-switch</id><content type="html" xml:base="http://localhost:4000/network/2024-01-16-network-switch/"><![CDATA[<blockquote>
  <p>🌷 <strong>개요</strong></p>

  <p><strong>스위치</strong></p>

  <ul>
    <li>2계층 장비</li>
    <li>네트워크의 가장 핵심적인 장비</li>
    <li>MAC 주소를 기반으로 동작</li>
  </ul>

  <p><strong>스위치의 기본 동작</strong></p>

  <ul>
    <li>네트워크 중간에서 패킷을 받아, 필요한 곳에만 보내준다. (네트워크의 통신을 중재)</li>
    <li>아무 설정을 하지 않고 연결만 해도 MAC 주소를 기반으로 패킷을 전달한다.</li>
  </ul>

  <p><strong>추가 기능</strong></p>

  <ul>
    <li>VLAN 기능 : 논리적으로 네트워크를 분리</li>
    <li>STP 기능 (스패닝 트리 프로토콜) : 네트워크의 루프 방지</li>
  </ul>
</blockquote>

<h1 id="vlan">VLAN</h1>

<h2 id="1-vlan이란">1. VLAN이란?</h2>

<ul>
  <li>LAN을 <code class="language-plaintext highlighter-rouge">논리적</code>으로 <code class="language-plaintext highlighter-rouge">분할</code>하는 기술</li>
  <li>
    <p>용도</p>

    <ul>
      <li>과도한 브로드캐스트로 인한 단말들의 성능 저하 방지, 보안 향상을 위한 차단 용도</li>
      <li>서비스 성격에 따른 정책 분리 적용</li>
      <li>각 부서별로 네트워크 분할</li>
      <li>단말별로 네트워크 분할</li>
    </ul>
  </li>
  <li>주의
    <ul>
      <li>VLAN 간의 통신은 3계층 장비를 통해서만 가능
        <ul>
          <li>서로 다른 네트워크로 분리되기 때문</li>
          <li>유니캐스트, 브로드캐스트 모두 3계층을 통해야함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-vlan의-종류">2. VLAN의 종류</h2>

<ul>
  <li>분류 기준: VLAN 할당 방식</li>
</ul>

<h3 id="포트-기반-vlan-일반적인-방식">포트 기반 VLAN (일반적인 방식)</h3>

<ul>
  <li>
    <p>스위치의 고정 포트에 VLAN 할당</p>

    <ul>
      <li>단말의 위치가 이동하면 다른 포트가 연결되어 VLAN이 변경</li>
    </ul>
  </li>
</ul>

<h3 id="mac-주소-기반-vlan">MAC 주소 기반 VLAN</h3>

<ul>
  <li>
    <p>스위치에 연결되는 단말의 MAC 주소에 VLAN 할당</p>

    <ul>
      <li>Dynamic VLAN 이라고도 부른다.</li>
      <li>단말에 따라 VLAN 정보가 바뀌기 때문</li>
      <li>단말의 위치가 이동하더라도 VLAN이 변경되지 않는다.</li>
    </ul>
  </li>
</ul>

<h2 id="3-vlan-모드-동작-방식-포트-기반-vlan">3. VLAN 모드 동작 방식 (포트 기반 VLAN)</h2>

<ul>
  <li>
    <p>VLAN의 특징</p>

    <ul>
      <li>한 대의 스위치에 연결하더라도 서로 다른 VLAN이 설정된 포트 간에는 통신할 수 없다.</li>
    </ul>
  </li>
  <li>
    <p>VLAN별 포트 연결의 문제</p>

    <ul>
      <li>하나의 스위치에는 하나의 VLAN이 연결되고, 하나의 VLAN은 하나의 포트를 사용하기 때문에 포트가 낭비 된다.</li>
    </ul>
  </li>
  <li>
    <p>해결</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">태그</code> 기능 사용</li>
    </ul>
  </li>
</ul>

<h3 id="태그-포트-트렁크-포트">태그 포트 (트렁크 포트)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">하나의 포트</code>에 <code class="language-plaintext highlighter-rouge">여러개의 VLAN</code> 전송
    <ul>
      <li>패킷 전송할 때 이더넷 프레임 중간에 VLAN ID 필드를 추가</li>
      <li>패킷 수신할 때 VLAN ID 제거</li>
    </ul>
  </li>
  <li>
    <p>MAC 주소 테이블에 VLAN ID도 저장</p>

    <ul>
      <li>VLAN 별로 MAC 주소를 사용할 수 있다.</li>
    </ul>
  </li>
  <li>여러 네트워크가 동시에 설정된 <code class="language-plaintext highlighter-rouge">스위치간의 연결</code>에서 사용</li>
</ul>

<h3 id="언태그-포트-액세스-포트">언태그 포트 (액세스 포트)</h3>

<ul>
  <li>하나의 네트워크에 속한 <code class="language-plaintext highlighter-rouge">서버</code>에 사용</li>
</ul>

<blockquote>
  <p>가상화 서버는 내부에 가상 스위치가 존재하므로 스위치 간 연결로 볼 수 있다.</p>

  <p><img src="https://heon-kim.github.io/assets/images/posts_img/network/2024-01-16-network-switch.jpeg" alt="가상화 서버 연결 구성" /></p>
</blockquote>]]></content><author><name>heon</name></author><category term="network" /><category term="network" /><summary type="html"><![CDATA[VLAN]]></summary></entry><entry><title type="html">스위치의 기본 동작</title><link href="http://localhost:4000/network/2024-01-15-network-switch/" rel="alternate" type="text/html" title="스위치의 기본 동작" /><published>2024-01-15T00:00:00+09:00</published><updated>2024-01-15T00:00:00+09:00</updated><id>http://localhost:4000/network/network-switch</id><content type="html" xml:base="http://localhost:4000/network/2024-01-15-network-switch/"><![CDATA[<blockquote>
  <p>🌷 <strong>개요</strong></p>

  <p><strong>스위치</strong></p>

  <ul>
    <li>2계층 장비</li>
    <li>네트워크의 가장 핵심적인 장비</li>
    <li>MAC 주소를 기반으로 동작</li>
  </ul>

  <p><strong>스위치의 기본 동작</strong></p>

  <ul>
    <li>네트워크 중간에서 패킷을 받아, 필요한 곳에만 보내준다. (네트워크의 통신을 중재)</li>
    <li>아무 설정을 하지 않고 연결만 해도 MAC 주소를 기반으로 패킷을 전달한다.</li>
  </ul>

  <p><strong>추가 기능</strong></p>

  <ul>
    <li>VLAN 기능 : 논리적으로 네트워크를 분리</li>
    <li>STP 기능 (스패닝 트리 프로토콜) : 네트워크의 루프 방지</li>
  </ul>
</blockquote>

<h2 id="스위치의-기본-동작">스위치의 기본 동작</h2>

<ul>
  <li>스위치의 필요성
    <ul>
      <li>스위치가 없다면
        <ul>
          <li>패킷을 전송할 때 서로 경합해 그로 인한 네트워크 성능 저하</li>
        </ul>
      </li>
      <li>스위치를 통해
        <ul>
          <li>패킷을 동시에 여러 장비가 서로 간섭없이 통신</li>
          <li>통신 효율성이 향상</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>스위치의 역할</p>

    <ul>
      <li>장비의 위치를 파악하고 <code class="language-plaintext highlighter-rouge">정확한 위치</code>로 패킷을 전송
        <ul>
          <li>정확한 위치는 <code class="language-plaintext highlighter-rouge">MAC 주소 테이블</code>을 통해 알 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>MAC 주소 테이블</p>

    <ul>
      <li>
        <p>MAC 주소와 포트 정보가 매핑되어 있다.</p>

        <table>
          <thead>
            <tr>
              <th>MAC 주소</th>
              <th>포트</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1111:2222:3333</td>
              <td>Eth1</td>
            </tr>
            <tr>
              <td>4444:5555:6666</td>
              <td>Eth2</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>스위치의 동작
    <ul>
      <li>테이블에 없는 주소를 가진 패킷은 전체 포트로 전송된다. (플러딩)</li>
      <li>테이블에 있는 주소를 가진 패킷은 해당 포트로만 전송된다. (포워딩 또는 필터링)</li>
    </ul>
  </li>
</ul>

<h3 id="1-플러딩-flooding">1. 플러딩 (Flooding)</h3>

<ul>
  <li>동작 방식 : 전체 포트로 패킷을 전달한다.</li>
  <li>동작 조건 :
    <ul>
      <li>MAC 주소 테이블에 일치하는 도착지 MAC 주소 정보가 없는 경우</li>
      <li>브로드캐스트, 멀티캐스트, 언노운 유니캐스트인 경우</li>
    </ul>
  </li>
  <li>플러딩 공격 기법
    <ul>
      <li>스위치에 잘못된 MAC 주소를 학습시킴</li>
      <li>MAC 테이블을 꽉 차게해 플러딩을 유도</li>
    </ul>
  </li>
</ul>

<h3 id="2-어드레스-러닝">2. 어드레스 러닝</h3>

<ul>
  <li>동작 방식 : MAC 주소 테이블을 만들고 유지한다.</li>
  <li>동작 조건 : 특정 포트에 들어온 패킷의 출발지 MAC 주소와 포트번호를 MAC 주소 테이블에 기록</li>
  <li>브로드캐스트나 멀티캐스트에 대한 MAC 주소를 학습할 수 없다!
    <ul>
      <li>출발지가 사용되지 않기 때문</li>
    </ul>
  </li>
</ul>

<h3 id="3-포워딩필터링">3. 포워딩/필터링</h3>

<ul>
  <li>동작 방식 : 특정 포트로 패킷을 전달</li>
  <li>동작 조건 :
    <ul>
      <li>MAC 주소 테이블에 일치하는 도착지 MAC 주소 정보가 있는 경우</li>
      <li>유니캐스트인 경우</li>
    </ul>
  </li>
</ul>]]></content><author><name>heon</name></author><category term="network" /><category term="network" /><summary type="html"><![CDATA[플러딩, 어드레스 러닝, 포워딩/필터링]]></summary></entry></feed>